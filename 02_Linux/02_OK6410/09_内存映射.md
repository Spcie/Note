###linux下的各种内存地址
机器语言指令中出现的内存地址，都是逻辑地址，需要转换成线性地址，再经过MMU转换成物理地址才能够被访问到。</br>
1. 物理地址:硬件向软件提供的地址</br>
3. 线性地址:线性地址的本质就是“CPU所看到的地址”，之所以叫线地址是因为这个地址对于CPU来说是一个连续的。线性地址也叫虚拟地址</br>
4. 逻辑地址:逻辑地址指程序产生的段内偏移地址，逻辑地址是相对于应用程序而言的。linux中逻辑地址等于线性地址</br>

###逻辑地址到线性地址的转化
逻辑地址有2部分组成16位长的段标示符(又叫段选择符)一个32位长的偏移量。</br>

|	15-3	|	2	|	1	0	|
|:---------:|:-----:|:---------:|
|	index	|	TI	|	RPL		|

TI表示指示器(0:在GDT中；1：LDT中) RPL表示请求者特权(linux中0：内核态；3：用户态。)</br>
处理器提供了6个分段寄存器（segmentation register）来缓存段选择符，它们是：cs,ss,ds,es,fs,gs</br>
cs-----内存段寄存器,指向含有代码指令的段,用于区分用户模式和内核模式</br>
ss-----堆栈段寄存器,指向包含当前程序栈的段</br>
ds-----数据段寄存器，指向包含静态和全局数据的段</br>
es,fs,gs作一般用途，可以指向任意的数据段</br>
cs有一个很重要的功能，它有2位字段(RPL)表示内核态和用户态。*(？是否代表其他寄存器里面的RPL不重要)*</br>

GDT:全局描述符表；LDT:局部描述符表</br>
通常只定义一个GDT(一个CPU对应一个GDT)，放在gdtr控制器中，LDT就每个进程可以有自己的LDT。当前正在使用的放在ldtr中</br>

**段描述符**</br>
386的每一个段选择符都有一个程序员不可见的88位宽的段描述符高速缓冲寄存器与之对应。</br>
无论什么时候改变了段寄存器的内容，只要特权级合理，描述符表中的相应的8字节描述符就会自动从描述符表中取出来，</br>
装入高速缓冲寄存器中(还有24位其他 内容)。一旦装入，以后对那个段的访问就都使用高速缓冲寄存器的描述符信息，而不会再重新从表中去取，这就大大加快了执行的时间</br>
段描述符的种类：</br>
1. 代码段描述符</br>
2. 数据段描述符</br>
3. 任务状态段描述符</br>
4. 局部描述符表描述符</br>

将逻辑地址转换为线性地址的称为分段单元。它转换时具体执行以下步骤：</br>
1. 检查选择符的TI段，获取描述符在GDT还是在LDT中，选择显影的gdtr和ldtr寄存器中得到线性基地址</br>
2. 选择符的index*8+之前得到的GDT或LDT的线性基地址，就可以得到描述符的地址</br>
3. 逻辑地址的偏移+描述符中的base字段(表示一个段的线性基地址)就可以得到线性地址</br>


###线性地址到物理地址的转化
线地址有3部分组成

|	31-22	|21-12	|	11-0	|
|:---------:|:-----:|:---------:|
| directory |table	|	offset	|

页目录表：大小为4KB（刚好是一个页的大小），包含1024项，每个项4字节（32位），表项里存储的内容就是页表的物理地址（因为物理页地址4k字节对齐，物理地址低12位总是0,所以表项里的最低12字节记录了一些其他信息）。</br>
页表：大小也是4k，同样包含1024项，每个项4字节，内容为最终物理页的物理内存起始地址。</br>
	
把线性地址转换为物理地址的叫分页单元。它转换时有3个步骤：</br>
1. 使用线地址bit31-bit22之间的directory在页目录中找到页表地址。</br>
2. 使用table在页表中找到物理页</br>
3. 使用offset在物理页中找到物理内存</br>
	
###虚拟内存区(VMA)
虚拟内存区至少包含有： </br>
1. 程序执行区（text区）</br>
2. 数据区(初始化数据data区；未初始化数据：BSS；堆：heap；栈：stack)。
3. 内存映射对应的区域

/proc/(pid)/maps 可以查看进程的内存区域 </br>
	信息以start-end perm major:minor inode image的形式显示 </br>
	
	例：
	cat /proc/1/maps
	08048000-0804e000 r-xp 00000000 03:01 64652  /sbin/init text
	......
    /proc/self 则始终指向当前进程
    /proc/(pid)/maps与vm_area_struct(<linux/mm.h>中定义表示一个)结构中的成员一一对应(vm_area_struct中不止这些成员)
    
    start：	虚拟内存起始地址
    end：	虚拟内存结束地址
    perm：	该虚拟内存区域的读、写、执行权限的位掩码,描述什么样的进程能访问属于该区域的页。最后一个字母是p表示私有，s表示共享
    offset：	表示内存映射去在文件中起始的位置。偏移量为0表示内存区域内的起始位置映射到文件开始的位置
    major：	主设备号
    minor：	次设备号
    inode：	被映射的文件的索引节点
    image：	被映射的文件名称


###mmap设备操作
映射一个设备意味着将用户空间的一段内存与设备内存关联起来。访问映射内存就是访问设备</br>
1. mmap是将设备内存线性地址映射到用户地址空间</br>
2. ioremap将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问</br>



