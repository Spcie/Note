<linux下的各种内存地址>
机器语言指令中出现的内存地址，都是逻辑地址，需要转换成线性地址，再经过MMU转换成物理地址才能够被访问到。
1.物理地址：硬件向软件提供的地址
3.线性地址：线性地址的本质就是“CPU所看到的地址”，之所以叫线地址是因为这个地址对于CPU来说是一个连续的。线性地址也叫虚拟地址
4.逻辑地址：逻辑地址指程序产生的段内偏移地址，逻辑地址是相对于应用程序而言的。linux中逻辑地址等于线性地址

<逻辑地址到线性地址的转化>
逻辑地址有2部分组成16位长的段标示符(又叫段选择符)一个32位长的偏移量。
	|	15-3	|	2	|	1	0	|
	|	index	|	TI	|	RPL		|
	TI表示指示器(0:在GDT中；1：LDT中) RPL表示请求者特权(linux中0：内核态；3：用户态。)
处理器提供了6个分段寄存器（segmentation register）来缓存段选择符，它们是：cs,ss,ds,es,fs,gs
cs-----内存段寄存器,指向含有代码指令的段,用于区分用户模式和内核模式
ss-----堆栈段寄存器,指向包含当前程序栈的段
ds-----数据段寄存器，指向包含静态和全局数据的段
es,fs,gs作一般用途，可以指向任意的数据段
cs有一个很重要的功能，它有2位字段(RPL)表示内核态和用户态。(？是否代表其他寄存器里面的RPL不重要)

GDT:全局描述符表；LDT:局部描述符表
通常只定义一个GDT(一个CPU对应一个GDT)，放在gdtr控制器中，LDT就每个进程可以有自己的LDT。当前正在使用的放在ldtr中

段描述符
386的每一个段选择符都有一个程序员不可见的88位宽的段描述符高速缓冲寄存器与之对应。
无论什么时候改变了段寄存器的内容，只要特权级合理，描述符表中的相应的8字节描述符就会自动从描述符表中取出来，
装入高速缓冲寄存器中(还有24位其他 内容)。一旦装入，以后对那个段的访问就都使用高速缓冲寄存器的描述符信息，而不会再重新从表中去取，这就大大加快了执行的时间
段描述符的种类：
1.代码段描述符
2.数据段描述符
3.任务状态段描述符
4.局部描述符表描述符

将逻辑地址转换为线性地址的称为分段单元。它转换时具体执行以下步骤：
1，检查选择符的TI段，获取描述符在GDT还是在LDT中，选择显影的gdtr和ldtr寄存器中得到线性基地址
2.选择符的index*8+之前得到的GDT或LDT的线性基地址，就可以得到描述符的地址
3.逻辑地址的偏移+描述符中的base字段(表示一个段的线性基地址)就可以得到线性地址


<线性地址到物理地址的转化>
线地址有3部分组成
	|	31-22		|	21-12	|	11-0	|
	|	directory	|	table	|	offset	|

页目录表：大小为4KB（刚好是一个页的大小），包含1024项，每个项4字节（32位），表项里存储的内容就是页表的物理地址（因为物理页地址4k字节对齐，物理地址低12位总是0,所以表项里的最低12字节记录了一些其他信息）。
页表：大小也是4k，同样包含1024项，每个项4字节，内容为最终物理页的物理内存起始地址。
	
把线性地址转换为物理地址的叫分页单元。它转换时有3个步骤：
1.使用线地址bit31-bit22之间的directory在页目录中找到页表地址。
2.使用table在页表中找到物理页
3.使用offset在物理页中找到物理内存
	
<虚拟内存区(VMA)>
虚拟内存区至少包含有： 
1.程序执行区（text区）
2.数据区(初始化数据data区；未初始化数据：BSS；堆：heap；栈：stack)。
3.内存映射对应的区域

/proc/(pid)/maps 可以查看进程的内存区域 
	信息以start-end perm major:minor inode image的形式显示
例：
	#cat /proc/1/maps
	08048000-0804e000 r-xp 00000000 03:01 64652  /sbin/init text
	......
	
/proc/self 则始终指向当前进程
/proc/(pid)/maps与vm_area_struct(<linux/mm.h>中定义表示一个)结构中的成员一一对应(vm_area_struct中不止这些成员)

start：	虚拟内存起始地址
end：	虚拟内存结束地址
perm：	该虚拟内存区域的读、写、执行权限的位掩码,描述什么样的进程能访问属于该区域的页。最后一个字母是p表示私有，s表示共享
offset：	表示内存映射去在文件中起始的位置。偏移量为0表示内存区域内的起始位置映射到文件开始的位置
major：	主设备号
minor：	次设备号
inode：	被映射的文件的索引节点
image：	被映射的文件名称


<mmap设备操作>
映射一个设备意味着将用户空间的一段内存与设备内存关联起来。访问映射内存就是访问设备
mmap是将设备内存线性地址映射到用户地址空间
内存映射函数mmap，负责把文件内容映射到进程的虚拟内存空间，通过对这一段内存的读取和修改，来实现对文件的读取和修改而不需要再调用read，write等操作

void* mmap(void* addr, size_t len, int prot,int flags,int fd,off_t offset)

addr:指定映射的起始地址，通常设为NULL，由系统指定
len：映射内存空间的长度
prot：映射区的保护方式
	PORT_EXEC:映射区可以被执行
	PORT_READ:映射区可以被读取
	PROT_WRITE:映射区可以被写入
flags：映射区的特性
	MAP_SHARED:写入映射区的数据复制回文件，且允许其他映射该文件的进程共享
	MAP_PRIVATE：对映射区的写入操作会产生一个映射区的复制(copy-on-write)，对此区域所有的修改不会写回原文件
fd：映射的文件
offse：文件的偏移

解除映射
int munmap(void *start,size_t length)
start为所指向映射内存，参数length表示欲取消的内存大小
返回0表示成功，否则返回-1，错误原因存于errno中

<mmap设备实现>

mmap设备的方法就是file_oprations结构的成员，在mmap系统调用发出时被调用。在此之前，内核已经完成了很多工作。
mmap设备需要做的就是建立虚拟地址到物理地址的页表，方法有2.
1.使用remap_pfn_range一次建立所有页表；
2.使用nopage VMA方法每次建立一个页表；

方法1中的函数
int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn,unsigned long size,pgprot_t prot);
vma：虚拟内存的区域指针
addr：虚拟地址的起始值
pfn：要映射物理地址所在的物理页帧号，可将物理地址>>PAGE_SHIFT得到
size：要映射区域的大小
prot：VMA的保护属性

实例
int memdev_mmap(struct file *filp, struct vm_area_struct *vma)
{
	vma->vm_flags |= VM_IO;
	vma->vm_flags |=VM_RESERVED;
	
	if(remap_pfn_range(vma,
		vma->vm_start,
		virt_to_phys(dev->data)>>PAGE_SHIFT,
		size,
		vma->vm_page_port))
	{
		return -EAGAIN;
	}
	
	return 0;
}